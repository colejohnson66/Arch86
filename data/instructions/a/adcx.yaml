%YAML 1.2
---
title: Unsigned Integer Addition of Two Operands with Carry Flag
opcode:
  - opcode: 66 0F 38 F6 /r
    mnemonic: ADCX \i{r32}, \i{r/m32}
    encoding: RM
    validity:
      16: invalid
      32: valid
      64: valid
    cpuid: ADX
    description: Unsigned addition of \i{r32} with carry flag and \i{r/m32} to \i{r32}.
  - opcode: 66 REX.W 0F 38 F6 /r
    mnemonic: ADCX \i{r64}, \i{r/m64}
    encoding: RM
    validity:
      16: n/e
      32: n/e
      64: valid
    cpuid: ADX
    description: Unsigned addition of \i{r64} with carry flag and \i{r/m64} to \i{r64}.
encoding:
  operands: 2
  encodings:
    RM:
      - ModRM.reg[rw]
      - ModRM.r/w[r]
description: >-
  The \c{ADCX} instruction adds the destination operand, the source operand, and the \reg{CF} flag and stores the result in the destination operand.

  This instruction is designed for use in multibyte additions such as in arbitrary precision arithmetic.
  The difference between this instruction and \instr{ADC} is that this one allows the creation of two "carry chains" \en{} one using \reg{CF} (this one) and one using \reg{OF} (\instr{ADOX}).
operation: >-
  public void ADCX_32(ref uint dest, uint src)
  {
    dest = dest + src + CF;
  }

  public void ADCX_64(ref ulong dest, ulong src)
  {
    dest = dest + src + CF;
  }
flags:
  CF: Set according to the result.
  PF: Unmodified.
  AF: Unmodified.
  ZF: Unmodified.
  SF: Unmodified.
  OF: Unmodified.
intrinsics: |-
  uint8_t _addcarryx_u32(uint8_t c_in, uint32_t src1, uint32_t src2, uint32_t *sum_out)
  uint8_t _addcarryx_u64(uint8_t c_in, uint64_t src1, uint64_t src2, uint64_t *sum_out)
exceptions:
  protected:
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=19=adx} is 0.
    "#SS(0)": \exception{segLimitSS}
    "#GP(0)":
      - \exception{segLimit}
      - \exception{nullSelector}
    "#PF(fc)": \exception{pf}
    "#AC(0)": \exception{ac}
  real:
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=19=adx} is 0.
    "#SS(0)": \exception{segLimitSS}
    "#GP(0)": \exception{segLimit}
  virtual:
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=19=adx} is 0.
    "#SS(0)": \exception{segLimitSS}
    "#GP(0)": \exception{segLimit}
    "#PF(fc)": \exception{pf}
    "#AC(0)": \exception{ac}
  compatibility: Same exceptions as in protected mode.
  long:
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=19=adx} is 0.
    "#SS(0)": \exception{nonCanonSS}
    "#GP(0)": \exception{nonCanon}
    "#PF(fc)": \exception{pf}
    "#AC(0)": \exception{ac}

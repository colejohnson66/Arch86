%YAML 1.2
---
title: Unsigned Integer Addition of Two Operands with Overflow Flag
opcode:
  - opcode: F3 0F 38 F6 /r
    mnemonic: ADOX \i{r32}, \i{r/m32}
    encoding: RM
    validity:
      16: invalid
      32: valid
      64: valid
    cpuid: ADX
    description: Unsigned addition of \i{r32} with overflow flag and \i{r/m32} to \i{r32}.
  - opcode: F3 REX.W 0F 38 F6 /r
    mnemonic: ADOX \i{r64}, \i{r/m64}
    encoding: RM
    validity:
      16: n/e
      32: n/e
      64: valid
    cpuid: ADX
    description: Unsigned addition of \i{r64} with overflow flag and \i{r/m64} to \i{r64}.
encoding:
  operands: 2
  encodings:
    RM:
      - ModRM.reg[rw]
      - ModRM.r/w[r]
description: >-
  The \c{ADOX} instruction adds the destination operand, the source operand, and the \reg{OF} flag.
  The result is stored in in the destination operand.

  This instruction is designed for use in multibyte additions such as in arbitrary precision arithmetic.
  The difference between this instruction and \instr{ADC} is that this one allows the creation of two "carry chains" \en{} one using \reg{OF} (this one) and one using \reg{CF} (\instr{ADCX}).
operation: >-
  public void ADOX_32(ref uint dest, uint src)
  {
    dest = dest + src + OF;
  }

  public void ADOX_64(ref ulong dest, ulong src)
  {
    dest = dest + src + OF;
  }
flags:
  CF: Unmodified.
  PF: Unmodified.
  AF: Unmodified.
  ZF: Unmodified.
  SF: Unmodified.
  OF: Set according to the result.
intrinsics: |-
  uint8_t _addcarryx_u32(uint8_t c_in, uint32_t src1, uint32_t src2, uint32_t *sum_out)
  uint8_t _addcarryx_u64(uint8_t c_in, uint64_t src1, uint64_t src2, uint64_t *sum_out)
exceptions:
  protected:
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=19=adx} is 0.
    "#SS(0)": \exception{segLimitSS}
    "#GP(0)":
      - \exception{segLimit}
      - \exception{nullSelector}
    "#PF(fc)": \exception{pf}
    "#AC(0)": \exception{ac}
  real:
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=19=adx} is 0.
    "#SS(0)": \exception{segLimitSS}
    "#GP(0)": \exception{segLimit}
  virtual:
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=19=adx} is 0.
    "#SS(0)": \exception{segLimitSS}
    "#GP(0)": \exception{segLimit}
    "#PF(fc)": \exception{pf}
    "#AC(0)": \exception{ac}
  compatibility: Same exceptions as in protected mode.
  long:
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=19=adx} is 0.
    "#SS(0)": \exception{nonCanonSS}
    "#GP(0)": \exception{nonCanon}
    "#PF(fc)": \exception{pf}
    "#AC(0)": \exception{ac}

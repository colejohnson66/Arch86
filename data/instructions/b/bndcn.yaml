%YAML 1.2
---
title: Check Upper Bound
opcode:
  - opcode: F2 0F 1B /r
    mnemonic: BNDCN \i{bnd}, \i{r/m32}
    encoding: RM
    validity:
      16: valid
      32: valid
      64: n/e
    cpuid: MPX
    description: >-
      Throws a \c{#BR} exception if the address in \i{r/m32} is greater than the upper bound in \i{bnd}.
  - opcode: F2 0F 1B /r
    mnemonic: BNDCN \i{bnd}, \i{r/m64}
    encoding: RM
    validity:
      16: n/e
      32: n/e
      64: valid
    cpuid: MPX
    description: >-
      Throws a \c{#BR} exception if the address in \i{r/m64} is greater than the upper bound in \i{bnd}.
encoding:
  operands: 2
  encodings:
    RM:
      - ModRM.reg[r]
      - ModRM.r/m[r]
description: >-
  The \c{BNDCN} instruction compares the address in the second source operand (a GPR or memory location) against the upper bound (\c{UB}) of the first source operand (a bound register).
  If the second source operand is greater, a \c{#BR} exception is thrown, and \c{BNDSTATUS} is set to \c{1h}.

  This instruction is similar to the \instr{BNDCU} instruction, except that one inverts the bound register (i.e. finds the one's complemented form) before comparison.

  If the second source operand is a general purpose register, the value contained in it is treated as the address to compare against.
  If, however, it is a memory location, the effective address is calculated (see \instr{LEA}) and used in the comparison.
  At no time is memory accessed, and the flags are untouched.

  Which instruction form (32 or 64 bit) is used depends on the operating mode of the processor.
  In 16 and 32 bit mode, the 32 bit form is used, and, in 64 bit mode, the 64 bit form is used.
  This distinction is irrelevant for the memory form.
operation: |-
  public void BNDCN(Bound bnd, IntPtr addr)
  {
    if (addr < bnd.upper)
    {
      BNDSTATUS.abd = 0;
      BNDSTATUS.ec = 1; // Bounds violation
      #BR;
    }
  }
intrinsics: |-
  void _bnd_chk_ptr_ubounds(const void *address)
exceptions:
  protected:
    "#BR": If the lower bounds check fails.
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
      - If 16 bit addressing is used.
  real: Same exceptions as protected mode.
  virtual: Same exceptions as protected mode.
  compatibility: Same exceptions as protected mode.
  long: Same exceptions as protected mode.
changes:
  version: 75
  date: 2021-06
  list:
    - >-
      The overview table only mentions 32 and 64 bit mode support.
      However, this instruction is supported in all modes.
    - >-
      The "Encoding" section incorrectly lists the first operand (the bound register) as being written to.
      It is actually only read.

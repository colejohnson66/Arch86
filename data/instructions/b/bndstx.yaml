%YAML 1.2
---
title: Store Extended Bounds Using Address Translation
opcode:
  - opcode: NP 0F 1B !(11):rrr:100
    mnemonic: BNDSTX \i{mib}, \i{bnd}
    encoding: RM
    validity:
      16: valid
      32: valid
      64: valid
    cpuid: MPX
    description: >-
      Store the bounds stored in a bound table entry (BTE) from \i{bnd} into \i{mib}.
encoding:
  operands: 2
  encodings:
    RM:
      - SIB.base[r] + SIB.index[r]
      - ModRM.reg[w]
description: >-
  The \c{BNDSTX} instruction stores the bounds at the source operand to the address pointed to by the destination operand.
  This is conditional on the value contained in the register referenced in the SIB's index field matching the value stored in the bounds table entry.

  The second source operand \i{must} be a memory operand encoded using an SIB byte.
  The \c{base} field of the SIB byte contains the address of the bounds table, and the \c{index} field contains the buffer's offset.
  The \c{scale} field is ignored.
  If a displacement is provided, it is added to the \c{base} register's value.
  At no time is memory directly referenced by the SIB byte accessed (the memory contained at the address referenced by the \c{base} \i{is}, however), and the flags are untouched.
operation: |-
  public void BNDSTX_1632(Sib addr, Bound src)
  {
    IntPtr base = addr.base + addr.displacement;
    uint ptr = GPR(addr.index);

    uint a_bde = (base[12..32] << 2) + (BNDCFG[12..32] << 12);
    uint a_bt = mem[a_bde];
    if (a_bt.Bit[0] == 0)
    {
      BNDSTATUS.bde = a_bde;
      BNDSTATUS.ec = 2; // Invalid BD entry
      #BR;
    }

    uint a_bte = (base[2..12] << 4) + (a_bt[2..32] << 2);
    mem[a_bte] = bound.lower;
    mem[a_bte + 4] = bound.upper;
    mem[a_bte + 8] = ptr;
  }

  public void BNDSTX_64(Bound dest, Sib addr)
  {
    IntPtr base = addr.base + addr.displacement;
    uint ptr = GPR(addr.index);

    uint a_bde = (base[20..(48+MAWA)] << 3) + (BNDCFG[12..64] << 12); // see note 1
    uint a_bt = mem[a_bde];
    if (a_bt.Bit[0] == 0)
    {
      BNDSTATUS.bde = a_bde;
      BNDSTATUS.ec = 2; // Invalid BD entry
      #BR;
    }

    ulong a_bte = (base[3..20] << 5) + (a_bt[3..64] << 3);
    mem[a_bte] = bound.lower;
    mem[a_bte + 8] = bound.upper;
    mem[a_bte + 16] = ptr;
  }
operationNotes:
  - >-
    If \c{CPL} (protection ring) is less than 3, the supervisor \c{MAWA} (\c{MAWAS}) is used, which is 0.
    Otherwise, the user \c{MAWA} (\c{MAWAU}) is used; it's value is enumerated in \cpuid{eax=07,ecx=00,,ecx=17..23=mawau}.
exceptions:
  real:
    "#BR": If the bound directory entry is invalid.
    "#UD":
      - \exception{lock}
      - \exception{sib}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
    "#GP(0)":
      - If the destination's effective address of the Bound Table entry is outside the \reg{DS} segment limit.
      - If the \reg{DS} segment contains a \c{NULL} segment selector.
  virtual:
    "#BR": If the bound directory entry is invalid.
    "#UD":
      - \exception{lock}
      - \exception{sib}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
    "#GP(0)":
      - If the destination's effective address of the Bound Table entry is outside the \reg{DS} segment limit.
      - If the \reg{DS} segment contains a \c{NULL} segment selector.
    "#PF(fc)": \exception{pf}
  protected:
    "#BR": If the bound directory entry is invalid.
    "#UD":
      - \exception{lock}
      - \exception{sib}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
    "#GP(0)":
      - If the destination's effective address of the Bound Table entry is outside the \reg{DS} segment limit.
      - If the \reg{DS} segment contains a \c{NULL} segment selector.
    "#PF(fc)": \exception{pf}
  compatibility:
    "#BR": If the bound directory entry is invalid.
    "#UD":
      - \exception{lock}
      - \exception{sib}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
    "#GP(0)":
      - If the destination's effective address of the Bound Table entry is outside the \reg{DS} segment limit.
      - If the \reg{DS} segment contains a \c{NULL} segment selector.
    "#PF(fc)": \exception{pf}
  long:
    "#BR": If the bound directory entry is invalid.
    "#UD":
      - \exception{lock}
      - \exception{sib}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
    "#GP(0)": If the memory address (\c{A_BDE} or \c{A_BTE}) is in non-canonical form.
    "#PF(fc)": \exception{pf}
changes:
  version: 76
  date: 2021-12
  list:
    - >-
      The overview table only mentions 32 and 64 bit mode support.
      However, this instruction is supported in all modes.
    - The encoding of the ModR/M byte has been changed from \c{/r} to show the restrictions on it.

%YAML 1.2
---
title: Load Extended Bounds Using Address Translation
opcode:
  - opcode: NP 0F 1A !(11):rrr:100
    mnemonic: BNDLDX \i{bnd}, \i{mib}
    encoding: RM
    validity:
      16: valid
      32: valid
      64: valid
    cpuid: MPX
    description: >-
      Load the bounds stored in a bound table entry (BTE) from \i{mib} into \i{bnd}.
encoding:
  operands: 2
  encodings:
    RM:
      - ModRM.reg[w]
      - SIB.base[r] + SIB.index[r]
description: >-
  The \c{BNDLDX} instruction conditionally loads the destination operand with the bounds referenced at the address pointed to by the source operand.
  This is conditional on the value contained in the register referenced in the SIB byte's \c{index} field matching the value stored in the bounds table entry.
  If the check fails, the destination is set to the \c{INIT} bounds value (lower = \c{0}, upper = \c{0}), allowing access to all available memory.

  The second source operand \i{must} be a memory operand encoded using an SIB byte.
  The \c{base} field of the SIB byte contains the address of the bounds table, and the \c{index} field contains the buffer's offset.
  The \c{scale} field is ignored.
  If a displacement is provided, it is added to the \c{base} register's value.
  At no time is memory directly referenced by the SIB byte accessed (the memory contained at the address referenced by the \c{base} \i{is}, however), and the flags are untouched.
operation: |-
  public void BNDLDX_1632(Bound dest, Sib addr)
  {
    IntPtr base = addr.base + addr.displacement;
    uint ptr = GPR(addr.index);

    uint a_bde = (base[12..32] << 2) + (BNDCFG[12..32] << 12);
    uint a_bt = mem[a_bde];
    if (a_bt.Bit[0] == 0)
    {
      BNDSTATUS.bde = a_bde;
      BNDSTATUS.ec = 2; // Invalid BD entry
      #BR;
    }

    uint a_bte = (base[2..12] << 4) + (a_bt[2..32] << 2);
    uint temp_lower = mem[a_bte];
    uint temp_upper = mem[a_bte + 4];
    uint temp_ptr = mem[a_bte + 8];
    if (temp_ptr == ptr)
    {
      dest.lower = temp_lower;
      dest.upper = temp_upper;
    }
    else
    {
      dest.lower = 0;
      dest.upper = 0;
    }
  }

  public void BNDLDX_64(Bound dest, Sib addr)
  {
    IntPtr base = addr.base + addr.displacement;
    uint ptr = GPR(addr.index);

    ulong a_bde = (base[20..(48+MAWA)] << 3) + (BNDCFG[12..64] << 12); // see note 1
    ulong a_bt = mem[a_bde];
    if (a_bt.Bit[0] == 0)
    {
      BNDSTATUS.bde = a_bde;
      BNDSTATUS.ec = 2; // Invalid BD entry
      #BR;
    }

    ulong a_bte = (base[3..20] << 5) + (a_bt[3..64] << 3);
    ulong temp_lower = mem[a_bte];
    ulong temp_upper = mem[a_bte + 8];
    ulong temp_ptr = mem[a_bte + 16];
    if (temp_ptr == ptr)
    {
      dest.lower = temp_lower;
      dest.upper = temp_upper;
    }
    else
    {
      dest.lower = 0;
      dest.upper = 0;
    }
  }
operationNotes:
  - >-
    If \c{CPL} (protection ring) is less than 3, the supervisor \c{MAWA} (\c{MAWAS}) is used, which is 0.
    Otherwise, the user \c{MAWA} (\c{MAWAU}) is used; it's value is enumerated in \cpuid{eax=07,ecx=00,,ecx=17..23=mawau}.
exceptions:
  protected:
    "#BR": If the bound directory entry is invalid.
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
      - If 16 bit addressing is used.
    "#GP(0)":
      - If the destination's effective address of the Bound Table entry is outside the \reg{DS} segment limit.
      - If the \reg{DS} segment contains a \c{NULL} segment selector.
    "#PF(fc)": \exception{pf}
  real:
    "#BR": If the bound directory entry is invalid.
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
      - If 16 bit addressing is used.
    "#GP(0)":
      - If the destination's effective address of the Bound Table entry is outside the \reg{DS} segment limit.
      - If the \reg{DS} segment contains a \c{NULL} segment selector.
  virtual: Same exceptions as protected mode.
  compatibility: Same exceptions as protected mode.
  long:
    "#BR": If the bound directory entry is invalid.
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
      - If 16 bit addressing is used.
    "#GP(0)": If the memory address (\c{A_BDE} or \c{A_BTE}) is in non-canonical form.
    "#PF(fc)": \exception{pf}
changes:
  version: 75
  date: 2021-06
  list:
    - >-
      The overview table only mentions 32 and 64 bit mode support.
      However, this instruction is supported in all modes.
    - The encoding of the ModR/M byte has been changed from \c{/r} to show the restrictions on it.

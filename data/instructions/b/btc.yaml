%YAML 1.2
---
title: Bit Test and Complement
opcode:
  - opcode: 0F BB /r
    mnemonic: BTC \i{r/m16}, \i{r16}
    encoding: MR
    validity:
      16: valid
      32: valid
      64: valid
    description: >-
      Store the bit specified in \i{r16} from \i{r/m16} into the \reg{CF} flag before complementing (inverting) the selected bit.
  - opcode: 0F BB /r
    mnemonic: BTC \i{r/m32}, \i{r32}
    encoding: MR
    validity:
      16: valid
      32: valid
      64: valid
    description: >-
      Store the bit specified in \i{r32} from \i{r/m32} into the \reg{CF} flag before complementing (inverting) the selected bit.
  - opcode: REX.W 0F BB /r
    mnemonic: BTC \i{r/m64}, \i{r64}
    encoding: MR
    validity:
      16: n/e
      32: n/e
      64: valid
    description: >-
      Store the bit specified in \i{r64} from \i{r/m64} into the \reg{CF} flag before complementing (inverting) the selected bit.
  - opcode: 0F BA /7 ib
    mnemonic: BTC \i{r/m16}, \i{imm8}
    encoding: MI
    validity:
      16: valid
      32: valid
      64: valid
    description: >-
      Store the bit specified in \i{imm8} from \i{r/m16} into the \reg{CF} flag before complementing (inverting) the selected bit.
  - opcode: 0F BA /7 ib
    mnemonic: BTC \i{r/m32}, \i{imm8}
    encoding: MI
    validity:
      16: valid
      32: valid
      64: valid
    description: >-
      Store the bit specified in \i{imm8} from \i{r/m32} into the \reg{CF} flag before complementing (inverting) the selected bit.
  - opcode: REX.W 0F BA /7 ib
    mnemonic: BTC \i{r/m64}, \i{imm8}
    encoding: MI
    validity:
      16: n/e
      32: n/e
      64: valid
    description: >-
      Store the bit specified in \i{imm8} from \i{r/m64} into the \reg{CF} flag before complementing (inverting) the selected bit.
encoding:
  operands: 2
  encodings:
    MR:
      - ModRM.r/m[rw]
      - ModRM.reg[r]
    MI:
      - ModRM.r/m[rw]
      - imm8[r]
description: >-
  The \c{BTC} instruction selects a bit from the destination operand and stores it in the \reg{CF} flag.
  The specific bit selected is specified in the source operand.
  Afterwards, the selected bit is complemented (inverted) and saved in the destination operand.

  If the source operand references a bit higher than the width of the destination operand (eg. the 21st bit in a 16 bit register), the upper bits are ignored.
  In other words, attempting to reference the 21st bit of a 16 bit register only accesses the \i{5th} bit (as 21 modulo 16 is 5).
operation: |-
  public void BTC_16(ushort src, ushort idx)
  {
    CF = src.Bit[idx % 16];
    src.Bit[idx % 16] = ~CF;
  }

  public void BTC_32(uint src, uint idx)
  {
    CF = src.Bit[idx % 32];
    src.Bit[idx % 32] = ~CF;
  }

  public void BTC_64(ulong src, ulong idx)
  {
    CF = src.Bit[idx % 64];
    src.Bit[idx % 64] = ~CF;
  }
flags:
  CF: Set if the selected bit is set (before being complemented). Cleared otherwise.
  PF: Undefined.
  AF: Undefined.
  ZF: Unmodified.
  SF: Undefined.
  OF: Undefined.
exceptions:
  protected:
    "#UD": \exception{lock}
    "#GP(0)":
      - \exception{segLimit}
      - \exception{nullSelector}
    "#SS(0)": \exception{segLimitSS}
    "#PF(fc)": \exception{pf}
    "#AC(0)": \exception{ac}
  real:
    "#UD": If the \instr{LOCK} prefix is used.
    "#GP": \exception{segLimit}
    "#SS": \exception{segLimitSS}
  virtual: Same exceptions as protected mode.
  compatibility: Same exceptions as protected mode.
  long:
    "#UD": \exception{lock}
    "#GP(0)": \exception{nonCanon}
    "#SS(0)": \exception{nonCanonSS}
    "#PF(fc)": \exception{pf}
    "#AC(0)": \exception{ac}

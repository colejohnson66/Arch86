%YAML 1.2
---
title: Bit Scan Reverse
opcode:
  - opcode: 0F BD /r
    mnemonic: BSR \i{r16}, \i{r/m16}
    encoding: RM
    validity:
      16: valid
      32: valid
      64: valid
    description: >-
      Stores the most significant set bit's position from \i{r/m16} into \i{r16}.
  - opcode: 0F BD /r
    mnemonic: BSR \i{r32}, \i{r/m32}
    encoding: RM
    validity:
      16: valid
      32: valid
      64: valid
    description: >-
      Stores the most significant set bit's position from \i{r/m32} into \i{r32}.
  - opcode: REX.W 0F BD /r
    mnemonic: BSR \i{r64}, \i{r/m64}
    encoding: RM
    validity:
      16: n/e
      32: n/e
      64: valid
    description: >-
      Stores the most significant set bit's position from \i{r/m64} into \i{r64}.
encoding:
  operands: 2
  encodings:
    RM:
      - ModRM.reg[w]
      - ModRM.r/m[r]
description: >-
  The \c{BSR} instruction searches the source operand for the most significant set bit.
  The zero-based index of this bit is stored in the destination operand.

  The \reg{ZF} flag is set if the source is 0 (no set bits), and cleared if a bit is found.
  If the \reg{ZF} flag is set, the value in the destination operand is undefined.
operation: |-
  public void BSR_16(ref ushort dest, ushort src)
  {
    if (src == 0)
    {
      ZF = 1;
      return;
      // dest (undefined)
    }

    uint idx = 15;
    while (src.Bit[idx] == 0)
      idx++;
    dest = idx;
    ZF = 0;
  }

  public void BSR_32(ref uint dest, uint src)
  {
    if (src == 0)
    {
      ZF = 1;
      return;
      // dest (undefined)
    }

    uint idx = 31;
    while (src.Bit[idx] == 0)
      idx--;
    dest = idx;
    ZF = 0;
  }

  public void BSR_64(ref ulong dest, ulong src)
  {
    if (src == 0)
    {
      ZF = 1;
      return;
      // dest (undefined)
    }

    uint idx = 63;
    while (src.Bit[idx] == 0)
      idx--;
    dest = idx;
    ZF = 0;
  }
flags:
  CF: Undefined.
  PF: Undefined.
  AF: Undefined.
  ZF: Set if the source is not zero. Cleared otherwise.
  SF: Undefined.
  OF: Undefined.
exceptions:
  protected:
    "#UD": \exception{lock}
    "#GP(0)":
      - \exception{segLimit}
      - \exception{nullSelector}
    "#SS(0)": \exception{segLimitSS}
    "#PF(fc)": \exception{pf}
    "#AC(0)": \exception{ac}
  real:
    "#UD": If the \instr{LOCK} prefix is used.
    "#GP": \exception{segLimit}
    "#SS": \exception{segLimitSS}
  virtual: Same exceptions as protected mode.
  compatibility: Same exceptions as protected mode.
  long:
    "#UD": \exception{lock}
    "#GP(0)": \exception{nonCanon}
    "#SS(0)": \exception{nonCanonSS}
    "#PF(fc)": \exception{pf}
    "#AC(0)": \exception{ac}

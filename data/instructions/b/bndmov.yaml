%YAML 1.2
---
title: Move Bounds
opcode:
  - opcode: 66 0F 1A /r
    mnemonic: BNDMOV \i{bnd1}, \i{bnd2/m64}
    encoding: RM
    validity:
      16: valid
      32: valid
      64: n/e
    cpuid: MPX
    description: >-
      Moves a lower and upper bound from \i{bnd2/m64} into \i{bnd1}.
  - opcode: 66 0F 1A /r
    mnemonic: BNDMOV \i{bnd1}, \i{bnd2/m128}
    encoding: RM
    validity:
      16: n/e
      32: n/e
      64: valid
    cpuid: MPX
    description: >-
      Moves a lower and upper bound from \i{bnd2/m128} into \i{bnd1}.
  - opcode: 66 0F 1B /r
    mnemonic: BNDMOV \i{bnd1/m64}, \i{bnd2}
    encoding: MR
    validity:
      16: valid
      32: valid
      64: n/e
    cpuid: MPX
    description: >-
      Moves a lower and upper bound from \i{bnd2} into \i{bnd1/m64}.
  - opcode: 66 0F 1B /r
    mnemonic: BNDMOV \i{bnd1/m128}, \i{bnd2}
    encoding: MR
    validity:
      16: n/e
      32: n/e
      64: valid
    cpuid: MPX
    description: >-
      Moves a lower and upper bound from \i{bnd2} into \i{bnd1/m128}.
encoding:
  operands: 2
  encodings:
    MR:
      - ModRM.reg[w]
      - ModRM.r/m[r]
    RM:
      - ModRM.r/m[w]
      - ModRM.reg[r]
description: >-
  The \c{BNDMOV} instruction moves a pair of lower and upper bounds from the source operand into the destination operand.

  Which instruction form (32 or 64 bit) is used depends on the operating mode of the processor.
  In 16 and 32 bit mode, the 32 bit form is used (64 bits are moved), and, in 64 bit mode, the 64 bit form is used (128 bits are moved).
operation: |-
  public void BNDMOV(ref Bound dest, Bound src)
  {
    dest = src;
  }
intrinsics: |-
  void *_bnd_copy_ptr_bounds(const void *q, const void *r)
exceptions:
  protected:
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} or \c{ModRM.r/m} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
      - If 16 bit addressing is used.
    "#SS(0)": \exception{segLimitSS}
    "#GP(0)":
      - \exception{segLimit}
      - \exception{nonWritableSegment}
      - \exception{nullSelector}
    "#AC(0)": \exception{ac}
    "#PF(fc)": \exception{pf}
  real:
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} or \c{ModRM.r/m} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
      - If 16 bit addressing is used.
    "#SS(0)": \exception{segLimitSS}
    "#GP(0)": \exception{segLimit}
  virtual: Same exceptions as protected mode.
  compatibility: Same exceptions as protected mode.
  long:
    "#UD":
      - \exception{lock}
      - If \cpuid{eax=07,ecx=00,,ebx=14=mpx} is \c{0}.
      - If \c{ModRM.reg} or \c{ModRM.r/m} does not encode \c{BND0} through \c{BND3} (i.e. contains a 4 or higher).
      - If 16 bit addressing is used.
      - If RIP-relative addressing is used.
    "#SS(0)": \exception{nonCanonSS}
    "#GP(0)": \exception{nonCanon}
    "#AC(0)": \exception{ac}
    "#PF(fc)": \exception{pf}
